---
title: "Features API Reference"
description: "Documentation for the Goodfire Features API"
---

The Features API provides methods for working with interpretable features of language models. Features represent learned patterns in model behavior that can be analyzed and modified.

## Core Classes

### Feature

A class representing a human-interpretable "feature" - a model's conceptual neural unit. Features can be combined into groups and compared using standard operators.

**Properties:**

<ResponseField name="uuid" type="UUID">
  Unique identifier for the feature
</ResponseField>

<ResponseField name="label" type="str">
  Human-readable label describing the feature
</ResponseField>

<ResponseField name="max_activation_strength" type="float">
  Maximum activation strength of the feature in the training dataset
</ResponseField>

<ResponseField name="index_in_sae" type="int">
  Feature index relative to all features in a given model
</ResponseField>

**Methods:**

- `json()`: Convert feature to JSON format
- `from_json(data)`: Create feature from JSON data
- Supports comparison operators (`==`, `!=`, `<=`, `<`, `>=`, `>`)

### FeatureGroup

A collection of Feature instances with group operations. Provides functionality for managing and operating on groups of features, including union and intersection operations, indexing, and comparison operations.

**Methods:**

<ResponseField name="add(feature)" type="method">
  Add a feature to the group
</ResponseField>

<ResponseField name="pop(index)" type="method">
  Remove and return feature at specified index
</ResponseField>

<ResponseField name="union(feature_group)" type="method">
  Combine this group with another feature group
</ResponseField>

<ResponseField name="intersection(feature_group)" type="method">
  Create new group with features common to both groups
</ResponseField>

**Example:**

```python
feature_group = FeatureGroup([feature1, feature2, feature3, feature4])

# Access single feature by index
first_feature = feature_group[0]  # Returns Feature

# Slice features
first_two = feature_group[0:2]    # Returns FeatureGroup with features 0,1
last_two = feature_group[-2:]     # Returns FeatureGroup with last 2 features

# Multiple indexes using list or tuple
selected = feature_group[[0, 2]]  # Returns FeatureGroup with features 0,2
selected = feature_group[0, 3]    # Returns FeatureGroup with features 0,3
```

### ConditionalGroup

Groups multiple conditions with logical operators.

**Properties:**

<ResponseField name="conditionals" type="list[Conditional]">
  List of Conditional instances to group
</ResponseField>

<ResponseField name="operator" type="str">
  Logical operator to join conditions ("AND" or "OR")
</ResponseField>

**Methods:**

- Supports logical operations (`&` for AND, `|` for OR)
- `json()`: Convert to JSON format
- `from_json()`: Create from JSON data

## Methods

### neighbors()

Get the nearest neighbors of a feature or group of features.

**Parameters:**

<ResponseField name="features" type="Feature | FeatureGroup" required>
  Feature or group of features to find neighbors for
</ResponseField>

<ResponseField name="model" type="str | VariantInterface" required>
  Model identifier or variant interface
</ResponseField>

<ResponseField name="top_k" type="int" default={10}>
  Number of neighbors to return
</ResponseField>

**Returns:** `FeatureGroup`

**Example:**

```python
# Get neighbors of a feature
neighbors = await client.features.neighbors(
    feature,
    model="meta-llama/Meta-Llama-3-8B-Instruct",
    top_k=10
)

# Print neighbor labels
for neighbor in neighbors:
    print(neighbor.label)
```

### search()

Search for features based on semantic similarity of feature labels to a query string.

**Parameters:**

<ResponseField name="query" type="str" required>
  Search string to compare against feature label embeddings
</ResponseField>

<ResponseField name="model" type="str | VariantInterface" required>
  Model identifier or variant interface
</ResponseField>

<ResponseField name="top_k" type="int" default={10}>
  Number of top features to return after searching
</ResponseField>

**Returns:** `tuple[FeatureGroup, list[float]]` - Features and their relevance scores

**Example:**

```python
# Search for features related to writing style
features, scores = await client.features.search(
    "formal writing style",
    model="meta-llama/Meta-Llama-3-8B-Instruct",
    top_k=10
)

# Print features and their relevance scores
for feature, score in zip(features, scores):
    print(f"{feature.label}: {score}")
```

### attribute()

Analyze feature attributions for a set of messages.

**Parameters:**

<ResponseField name="messages" type="list[ChatMessage]" required>
  Messages to analyze
</ResponseField>

<ResponseField name="model" type="str | VariantInterface" required>
  Model identifier or variant interface
</ResponseField>

**Returns:** `FeatureGroup`

**Example:**

```python
# Get feature attributions
features = await client.features.attribute(
    messages=[{"role": "user", "content": "Hello world"}],
    model="meta-llama/Meta-Llama-3-8B-Instruct"
)
```

### steer_to_token()

Get features that steer towards or away from a specific token.

**Parameters:**

<ResponseField name="messages" type="list[ChatMessage]" required>
  Messages to analyze
</ResponseField>

<ResponseField name="model" type="str | VariantInterface" required>
  Model identifier or variant interface
</ResponseField>

<ResponseField name="steer_to" type="str" required>
  Token to steer towards
</ResponseField>

**Returns:** `tuple[FeatureGroup, FeatureGroup]` - Features to add and features to remove

**Example:**

```python
# Get features for steering to a token
features_to_add, features_to_remove = await client.features.steer_to_token(
    messages=[{"role": "user", "content": "Hello"}],
    model="meta-llama/Meta-Llama-3-8B-Instruct",
    steer_to="world"
)
```

### generate_contrastive_stimulus()

Generate contrastive examples based on a specification.

**Parameters:**

<ResponseField name="specification" type="str" required>
  Specification for generating contrastive examples
</ResponseField>

**Returns:** `tuple[Any, Any]` - Two contrastive examples

**Example:**

```python
# Generate contrastive examples
example1, example2 = await client.features.generate_contrastive_stimulus(
    "Generate formal vs informal writing examples"
)
```

### inspect()

Analyzes how features are activated across the input messages.

**Parameters:**

<ResponseField name="messages" type="list[ChatMessage]" required>
  Messages to analyze
</ResponseField>

<ResponseField name="model" type="str | VariantInterface" required>
  Model identifier or variant interface
</ResponseField>

<ResponseField name="features" type="Feature | FeatureGroup | None">
  Optional specific features to analyze. If None, inspects all features.
</ResponseField>

<ResponseField name="aggregate_by" type="str" default="frequency">
  Method to aggregate feature activations across tokens: - "frequency": Count of
  tokens where feature is active - "mean": Mean activation value across tokens -
  "max": Maximum activation value across tokens - "sum": Sum of activation
  values across tokens
</ResponseField>

**Returns:** `ContextInspector` - An inspector object that provides methods for analyzing and visualizing how features are activated in the given context.

**Example:**

```python
# Analyze feature activations in text
inspector = await client.features.inspect(
    messages=[{"role": "user", "content": "Hello world"}],
    model="meta-llama/Meta-Llama-3-8B-Instruct",
    aggregate_by="frequency"
)

# Get top activated features
for activation in inspector.top(k=5):
    print(f"{activation.feature.label}: {activation.activation}")
```

### contrast()

Identify features that differentiate between two conversation datasets.

**Parameters:**

<ResponseField name="dataset_1" type="list[list[ChatMessage]]" required>
  First dataset of conversations
</ResponseField>

<ResponseField name="dataset_2" type="list[list[ChatMessage]]" required>
  Second dataset of conversations
</ResponseField>

<ResponseField name="model" type="str | VariantInterface" required>
  Model identifier or variant interface
</ResponseField>

<ResponseField name="top_k" type="int" default={5}>
  Number of top features to return for each dataset
</ResponseField>

**Returns:** `tuple[FeatureGroup, FeatureGroup]` - Two FeatureGroups containing:

- Features steering towards dataset_1
- Features steering towards dataset_2

**Example:**

```python
# Compare formal vs informal conversations
dataset_1 = [[
    {"role": "user", "content": "Hi how are you?"},
    {"role": "assistant", "content": "I'm doing well..."}
]]
dataset_2 = [[
    {"role": "user", "content": "Hi how are you?"},
    {"role": "assistant", "content": "Arr my spirits be high..."}
]]

formal_features, informal_features = await client.features.contrast(
    dataset_1=dataset_1,
    dataset_2=dataset_2,
    model="meta-llama/Meta-Llama-3-8B-Instruct",
    top_k=5
)
```

### dimension_reduction()

Reduce the dimensionality of a set of features around a center feature.

**Parameters:**

<ResponseField name="center" type="Feature" required>
  Center feature for dimension reduction
</ResponseField>

<ResponseField name="features" type="FeatureGroup" required>
  Features to reduce dimensions for
</ResponseField>

<ResponseField name="model" type="str | VariantInterface" required>
  Model identifier or variant interface
</ResponseField>

<ResponseField name="dimensions" type="int" default={2}>
  Number of dimensions to reduce to
</ResponseField>

**Returns:** `list[list[float]]` - Reduced feature coordinates

**Example:**

```python
# Reduce dimensions of features around a center feature
coordinates = await client.features.dimension_reduction(
    center=feature,
    features=feature_group,
    model="meta-llama/Meta-Llama-3-8B-Instruct",
    dimensions=2
)
```

### rerank()

Rerank a set of features based on a query.

**Parameters:**

<ResponseField name="features" type="FeatureGroup" required>
  Features to rerank
</ResponseField>

<ResponseField name="query" type="str" required>
  Query to rerank features by
</ResponseField>

<ResponseField name="model" type="str | VariantInterface" required>
  Model identifier or variant interface
</ResponseField>

<ResponseField name="top_k" type="int" default={10}>
  Number of top features to return
</ResponseField>

**Returns:** `FeatureGroup`

**Example:**

```python
# Rerank features based on relevance to "writing style"
reranked = await client.features.rerank(
    features=feature_group,
    query="writing style",
    model="meta-llama/Meta-Llama-3-8B-Instruct",
    top_k=10
)
```

### activations()

Retrieves feature activation values for each token in the input messages.

**Parameters:**

<ResponseField name="messages" type="list[ChatMessage]" required>
  Messages to analyze
</ResponseField>

<ResponseField name="model" type="str | VariantInterface" required>
  Model identifier or variant interface
</ResponseField>

<ResponseField name="features" type="Feature | FeatureGroup | None">
  Optional specific features to analyze. If None, analyzes all features.
</ResponseField>

**Returns:** `NDArray[np.float64]` - Sparse activation matrix of shape [n_tokens, n_features] where each element represents the activation strength of a feature at a specific token. Most values are zero due to sparsity.

**Example:**

```python
# Get activation matrix for a conversation
matrix = await client.features.activations(
    messages=[{"role": "user", "content": "Hello world"}],
    model="meta-llama/Meta-Llama-3-8B-Instruct"
)
```

### lookup()

Retrieves details for a list of features by their indices.

**Parameters:**

<ResponseField name="indices" type="list[int]" required>
  List of feature indices to fetch
</ResponseField>

<ResponseField name="model" type="str | VariantInterface" required>
  Model identifier or variant interface
</ResponseField>

**Returns:** `dict[int, Feature]` - Mapping of feature index to Feature object

### list()

Retrieves details for a list of features by their UUIDs.

**Parameters:**

<ResponseField name="ids" type="list[str]" required>
  List of feature UUIDs to fetch
</ResponseField>

**Returns:** `FeatureGroup` - Collection of Feature objects

## Feature Objects

### Feature

Represents a single interpretable feature.

**Properties:**

<ResponseField name="uuid" type="str">
  Unique identifier for the feature
</ResponseField>

<ResponseField name="label" type="str">
  Human-readable description of the feature
</ResponseField>

<ResponseField name="max_activation_strength" type="float">
  Maximum activation strength observed
</ResponseField>

<ResponseField name="index_in_sae" type="int">
  Index in the sparse autoencoder
</ResponseField>

### FeatureGroup

A collection of features.

**Example:**

```python
# Create a feature group
features = FeatureGroup([feature1, feature2, feature3])

# Iterate through features
for feature in features:
    print(feature.label)
```

### FeatureActivation

Represents the activation of a feature.

**Properties:**

<ResponseField name="feature" type="Feature">
  The activated feature
</ResponseField>

<ResponseField name="activation" type="float">
  Activation strength
</ResponseField>

### ContextInspector

Analyzes feature activations in text.

**Methods:**

<ResponseField name="top" type="method">
  Get top activated features.

```python
# Get top 5 activated features
top_features = inspector.top(k=5)
```

</ResponseField>

<ResponseField name="matrix" type="method">
  Get the full activation matrix.

```python
# Get activation matrix and feature lookup
matrix, feature_lookup = inspector.matrix(return_lookup=True)
```

</ResponseField>
